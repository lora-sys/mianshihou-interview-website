# 设备识别和并发登录检测方案（无数据库迁移版）

## 1. 概述

本方案**无需修改数据库表结构**，完全基于 Redis 实现设备识别和并发登录检测。

### 1.1 设计原则
- **零数据库迁移**：不修改 Better-Auth 的 session 表
- **纯 Redis 存储**：所有设备信息存储在 Redis 中
- **基于现有字段**：利用 Better-Auth 已有的 `ipAddress` 和 `userAgent`
- **降级友好**：Redis 故障时不影响正常登录

---

## 2. 技术方案

### 2.1 设备指纹生成

基于 IP 地址和 User-Agent 生成哈希指纹：

```typescript
function generateDeviceFingerprint(ip: string, userAgent: string): string {
  const raw = `${ip}:${userAgent}`;
  return crypto
    .createHash('sha256')
    .update(raw)
    .digest('hex')
    .substring(0, 16);
}
```

### 2.2 Redis 数据结构

#### 2.2.1 用户活跃设备列表
```
Key: devices:{userId}
Type: List
Value: [deviceFingerprint1, deviceFingerprint2, ...]
TTL: 7天
```

#### 2.2.2 设备详细信息
```
Key: device:{userId}:{deviceFingerprint}
Type: Hash
Fields:
  - deviceName: string
  - platform: string
  - browser: string
  - firstSeen: timestamp
  - lastSeen: timestamp
  - sessionCount: number
TTL: 7天
```

#### 2.2.3 设备会话列表
```
Key: device_sessions:{userId}:{deviceFingerprint}
Type: Set
Value: [sessionId1, sessionId2, ...]
TTL: 会话过期时间
```

#### 2.2.4 并发登录锁
```
Key: login_lock:{userId}
Type: String
Value: timestamp
TTL: 5秒（防止并发登录竞争）
```

---

## 3. 核心模块实现

### 3.1 设备指纹模块

**文件**：`mianshihou/apps/api/lib/device-fingerprint.ts`

```typescript
import crypto from 'crypto';

export interface DeviceInfo {
  fingerprint: string;
  deviceName: string;
  platform: string;
  browser: string;
}

/**
 * 生成设备指纹（基于 IP 和 User-Agent）
 */
export function generateDeviceFingerprint(ip: string, userAgent: string): string {
  const raw = `${ip}:${userAgent}`;
  return crypto
    .createHash('sha256')
    .update(raw)
    .digest('hex')
    .substring(0, 16);
}

/**
 * 解析设备信息
 */
export function parseDeviceInfo(userAgent: string): Omit<DeviceInfo, 'fingerprint'> {
  const ua = userAgent.toLowerCase();

  // 提取设备名称
  let deviceName = 'Unknown Device';
  if (ua.includes('mobile')) deviceName = 'Mobile Device';
  else if (ua.includes('tablet')) deviceName = 'Tablet';
  else if (ua.includes('android')) deviceName = 'Android Device';
  else if (ua.includes('iphone') || ua.includes('ipad')) deviceName = 'iOS Device';
  else if (ua.includes('mac')) deviceName = 'Macintosh';
  else if (ua.includes('windows')) deviceName = 'Windows PC';
  else if (ua.includes('linux')) deviceName = 'Linux PC';

  // 提取平台
  let platform = 'Unknown';
  if (ua.includes('android')) platform = 'Android';
  else if (ua.includes('iphone') || ua.includes('ipad')) platform = 'iOS';
  else if (ua.includes('mac os')) platform = 'macOS';
  else if (ua.includes('windows')) platform = 'Windows';
  else if (ua.includes('linux')) platform = 'Linux';

  // 提取浏览器
  let browser = 'Unknown';
  if (ua.includes('edg/')) browser = 'Edge';
  else if (ua.includes('chrome/') && !ua.includes('edg/')) browser = 'Chrome';
  else if (ua.includes('firefox/')) browser = 'Firefox';
  else if (ua.includes('safari/') && !ua.includes('chrome/')) browser = 'Safari';

  return { deviceName, platform, browser };
}

/**
 * 生成完整设备信息
 */
export function generateDeviceInfo(ip: string, userAgent: string): DeviceInfo {
  const fingerprint = generateDeviceFingerprint(ip, userAgent);
  const { deviceName, platform, browser } = parseDeviceInfo(userAgent);

  return { fingerprint, deviceName, platform, browser };
}
```

### 3.2 并发登录管理模块

**文件**：`mianshihou/apps/api/lib/concurrent-login.ts`

```typescript
import { redis } from '@/lib/redis';
import { logger } from '@/lib/logger';
import { AppError } from '@/lib/errors';
import { generateDeviceInfo } from '@/lib/device-fingerprint';

export interface ConcurrentConfig {
  maxDevices: number;
  onNewLogin: 'kick_oldest' | 'deny' | 'allow';
}

const DEFAULT_CONFIG: ConcurrentConfig = {
  maxDevices: 3,
  onNewLogin: 'kick_oldest',
};

/**
 * 检查并处理并发登录
 */
export async function handleConcurrentLogin(
  userId: string,
  ip: string,
  userAgent: string,
  sessionId: string,
  config: ConcurrentConfig = DEFAULT_CONFIG
): Promise<{ allowed: boolean; message?: string }> {
  const deviceInfo = generateDeviceInfo(ip, userAgent);

  try {
    // 获取分布式锁，防止并发问题
    const lockKey = `login_lock:${userId}`;
    const lockAcquired = await redis.set(lockKey, '1', {
      nx: true,
      ex: 5,
    });

    if (!lockAcquired) {
      // 获取锁失败，等待后重试
      await new Promise(resolve => setTimeout(resolve, 100));
      return handleConcurrentLogin(userId, ip, userAgent, sessionId, config);
    }

    try {
      // 获取用户当前活跃设备列表
      const devicesKey = `devices:${userId}`;
      const devices = await redis.lrange(devicesKey, 0, -1);

      // 检查是否是新设备
      const isExistingDevice = devices.includes(deviceInfo.fingerprint);
      const uniqueDevices = devices.length;

      // 如果设备已存在，直接允许
      if (isExistingDevice) {
        await updateDeviceSession(userId, deviceInfo.fingerprint, sessionId);
        await updateLastSeen(userId, deviceInfo.fingerprint);
        return { allowed: true };
      }

      // 新设备登录
      if (uniqueDevices >= config.maxDevices) {
        switch (config.onNewLogin) {
          case 'deny':
            return {
              allowed: false,
              message: `登录失败：您已在${uniqueDevices}个设备上登录，达到上限`,
            };
          case 'kick_oldest':
            await removeOldestDevice(userId);
            await registerNewDevice(userId, deviceInfo, sessionId);
            logger.info({
              context: 'ConcurrentLogin',
              userId,
              deviceFingerprint: deviceInfo.fingerprint,
              message: '踢出最旧的设备以允许新设备登录',
            });
            return { allowed: true };
          case 'allow':
            await registerNewDevice(userId, deviceInfo, sessionId);
            return { allowed: true };
        }
      }

      // 注册新设备
      await registerNewDevice(userId, deviceInfo, sessionId);

      logger.info({
        context: 'ConcurrentLogin',
        userId,
        deviceFingerprint: deviceInfo.fingerprint,
        deviceName: deviceInfo.deviceName,
        message: '新设备登录',
      });

      return { allowed: true };
    } finally {
      // 释放锁
      await redis.del(lockKey);
    }
  } catch (error) {
    logger.error({
      context: 'ConcurrentLogin',
      userId,
      error,
      message: '处理并发登录时发生错误',
    });
    // 出错时允许登录，避免阻塞用户
    return { allowed: true };
  }
}

/**
 * 注册新设备
 */
async function registerNewDevice(
  userId: string,
  deviceInfo: ReturnType<typeof generateDeviceInfo>,
  sessionId: string
): Promise<void> {
  const devicesKey = `devices:${userId}`;
  const deviceKey = `device:${userId}:${deviceInfo.fingerprint}`;
  const sessionsKey = `device_sessions:${userId}:${deviceInfo.fingerprint}`;

  // 添加到设备列表
  await redis.rpush(devicesKey, deviceInfo.fingerprint);
  await redis.expire(devicesKey, 7 * 24 * 60 * 60); // 7天

  // 设置设备信息
  await redis.hset(deviceKey, {
    deviceName: deviceInfo.deviceName,
    platform: deviceInfo.platform,
    browser: deviceInfo.browser,
    firstSeen: Date.now(),
    lastSeen: Date.now(),
    sessionCount: 1,
  });
  await redis.expire(deviceKey, 7 * 24 * 60 * 60);

  // 添加会话
  await redis.sadd(sessionsKey, sessionId);
}

/**
 * 更新设备的会话
 */
async function updateDeviceSession(
  userId: string,
  deviceFingerprint: string,
  sessionId: string
): Promise<void> {
  const sessionsKey = `device_sessions:${userId}:${deviceFingerprint}`;

  // 添加会话
  await redis.sadd(sessionsKey, sessionId);

  // 更新会话计数
  const deviceKey = `device:${userId}:${deviceFingerprint}`;
  await redis.hincrby(deviceKey, 'sessionCount', 1);
}

/**
 * 更新设备最后活跃时间
 */
async function updateLastSeen(
  userId: string,
  deviceFingerprint: string
): Promise<void> {
  const deviceKey = `device:${userId}:${deviceFingerprint}`;
  await redis.hset(deviceKey, 'lastSeen', Date.now());
}

/**
 * 移除最旧的设备
 */
async function removeOldestDevice(userId: string): Promise<void> {
  const devicesKey = `devices:${userId}`;

  // 获取最旧的设备指纹
  const oldestFingerprint = await redis.lindex(devicesKey, 0);
  if (!oldestFingerprint) return;

  // 从设备列表中移除
  await redis.lrem(devicesKey, 1, oldestFingerprint);

  // 获取该设备的所有会话
  const sessionsKey = `device_sessions:${userId}:${oldestFingerprint}`;
  const sessions = await redis.smembers(sessionsKey);

  // 清除所有会话的缓存
  for (const sessionId of sessions) {
    await redis.del(`session:${sessionId}`);
  }

  // 删除设备相关数据
  await redis.del(sessionsKey);
  await redis.del(`device:${userId}:${oldestFingerprint}`);

  logger.info({
    context: 'ConcurrentLogin',
    userId,
    deviceFingerprint: oldestFingerprint,
    message: '移除最旧的设备',
  });
}

/**
 * 获取用户的所有活跃设备
 */
export async function getUserActiveDevices(userId: string) {
  const devicesKey = `devices:${userId}`;
  const devices = await redis.lrange(devicesKey, 0, -1);

  const deviceInfos = [];
  for (const fingerprint of devices) {
    const deviceKey = `device:${userId}:${fingerprint}`;
    const info = await redis.hgetall(deviceKey);

    if (Object.keys(info).length > 0) {
      deviceInfos.push({
        fingerprint,
        deviceName: info.deviceName || 'Unknown Device',
        platform: info.platform || 'Unknown',
        browser: info.browser || 'Unknown',
        firstSeen: parseInt(info.firstSeen || '0'),
        lastSeen: parseInt(info.lastSeen || '0'),
        sessionCount: parseInt(info.sessionCount || '0'),
      });
    }
  }

  return deviceInfos;
}

/**
 * 踢出指定设备
 */
export async function revokeDevice(
  userId: string,
  deviceFingerprint: string
): Promise<void> {
  const devicesKey = `devices:${userId}`;

  // 从设备列表中移除
  await redis.lrem(devicesKey, 1, deviceFingerprint);

  // 获取该设备的所有会话
  const sessionsKey = `device_sessions:${userId}:${deviceFingerprint}`;
  const sessions = await redis.smembers(sessionsKey);

  // 清除所有会话的缓存
  for (const sessionId of sessions) {
    await redis.del(`session:${sessionId}`);
  }

  // 删除设备相关数据
  await redis.del(sessionsKey);
  await redis.del(`device:${userId}:${deviceFingerprint}`);

  logger.info({
    context: 'ConcurrentLogin',
    userId,
    deviceFingerprint,
    message: '用户踢出设备',
  });
}

/**
 * 清理用户的过期会话
 */
export async function cleanupUserSessions(
  userId: string,
  activeSessionIds: string[]
): Promise<void> {
  const devicesKey = `devices:${userId}`;
  const devices = await redis.lrange(devicesKey, 0, -1);

  for (const fingerprint of devices) {
    const sessionsKey = `device_sessions:${userId}:${fingerprint}`;
    const sessions = await redis.smembers(sessionsKey);

    // 移除已失效的会话
    for (const sessionId of sessions) {
      if (!activeSessionIds.includes(sessionId)) {
        await redis.srem(sessionsKey, sessionId);
      }
    }

    // 如果设备没有活跃会话，移除设备
    const remainingSessions = await redis.smembers(sessionsKey);
    if (remainingSessions.length === 0) {
      await redis.lrem(devicesKey, 1, fingerprint);
      await redis.del(sessionsKey);
      await redis.del(`device:${userId}:${fingerprint}`);
    }
  }
}

/**
 * 踢出用户的所有设备
 */
export async function revokeAllDevices(userId: string): Promise<void> {
  const devicesKey = `devices:${userId}`;

  // 获取所有设备
  const devices = await redis.lrange(devicesKey, 0, -1);

  // 移除每个设备
  for (const fingerprint of devices) {
    await revokeDevice(userId, fingerprint);
  }

  logger.info({
    context: 'ConcurrentLogin',
    userId,
    message: '踢出所有设备',
  });
}
```

### 3.3 更新认证路由

**文件**：`mianshihou/apps/api/trpc/router/auth.ts`

```typescript
import { z } from 'zod';
import { publicProcedure, router } from '../index';
import { auth } from '@/lib/auth';
import { handleConcurrentLogin, getUserActiveDevices, revokeDevice, revokeAllDevices } from '@/lib/concurrent-login';
import { db } from '@/db';
import { sessions } from '@/db/schema';
import { eq } from 'drizzle-orm';

export const authRouter = router({
  // ... 其他路由

  /**
   * 登录（带并发登录检测）
   */
  signIn: publicProcedure
    .input(z.object({
      email: z.string().email(),
      password: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      // Better-Auth 登录
      const session = await auth.api.signInEmail({
        body: {
          email: input.email,
          password: input.password,
        },
      });

      if (!session) {
        throw new AppError('INVALID_CREDENTIALS', '邮箱或密码错误');
      }

      const ip = ctx.ip || 'unknown';
      const userAgent = ctx.request.headers['user-agent'] || 'unknown';

      // 检查并发登录
      const concurrentCheck = await handleConcurrentLogin(
        session.user.id,
        ip,
        userAgent,
        session.session.id
      );

      if (!concurrentCheck.allowed) {
        // 登出当前会话
        await auth.api.signOut({ headers: ctx.request.headers });

        throw new AppError(
          'CONCURRENT_LOGIN_LIMIT',
          concurrentCheck.message || '达到设备登录上限'
        );
      }

      logger.info({
        context: 'Auth',
        userId: session.user.id,
        ip,
        message: '用户登录成功',
      });

      return session;
    }),

  /**
   * 获取当前用户的活跃设备列表
   */
  myDevices: publicProcedure
    .mutation(async ({ ctx }) => {
      const session = await auth.api.getSession({ headers: ctx.request.headers });
      if (!session) {
        throw new AppError('UNAUTHORIZED', '未登录');
      }

      const devices = await getUserActiveDevices(session.user.id);
      return devices;
    }),

  /**
   * 踢出指定设备
   */
  revokeDevice: publicProcedure
    .input(z.object({
      deviceFingerprint: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      const session = await auth.api.getSession({ headers: ctx.request.headers });
      if (!session) {
        throw new AppError('UNAUTHORIZED', '未登录');
      }

      await revokeDevice(session.user.id, input.deviceFingerprint);

      return { success: true };
    }),

  /**
   * 踢出所有设备（当前设备除外）
   */
  revokeAllDevices: publicProcedure
    .mutation(async ({ ctx }) => {
      const session = await auth.api.getSession({ headers: ctx.request.headers });
      if (!session) {
        throw new AppError('UNAUTHORIZED', '未登录');
      }

      // 获取当前设备的指纹
      const ip = ctx.ip || 'unknown';
      const userAgent = ctx.request.headers['user-agent'] || 'unknown';
      const { fingerprint: currentFingerprint } = generateDeviceInfo(ip, userAgent);

      // 获取所有设备
      const allDevices = await getUserActiveDevices(session.user.id);

      // 踢出其他设备
      for (const device of allDevices) {
        if (device.fingerprint !== currentFingerprint) {
          await revokeDevice(session.user.id, device.fingerprint);
        }
      }

      return { success: true };
    }),
});
```

### 3.4 中间件：定期清理过期会话

**文件**：`mianshihou/apps/api/tasks/cleanup/sessions.ts`

```typescript
import { db } from '@/db';
import { sessions } from '@/db/schema';
import { eq, and, lt } from 'drizzle-orm';
import { logger } from '@/lib/logger';
import { redis } from '@/lib/redis';
import { cleanupUserSessions } from '@/lib/concurrent-login';

/**
 * 清理过期会话并更新设备信息
 */
export async function cleanupExpiredSessions(): Promise<void> {
  try {
    const now = new Date();

    // 查询所有过期会话
    const expiredSessions = await db
      .select({
        id: sessions.id,
        userId: sessions.userId,
        token: sessions.token,
      })
      .from(sessions)
      .where(lt(sessions.expiresAt, now));

    if (expiredSessions.length === 0) {
      return;
    }

    logger.info({
      taskName: 'cleanupExpiredSessions',
      expiredCount: expiredSessions.length,
      message: '开始清理过期会话...',
    });

    // 按用户分组
    const userSessions = new Map<string, string[]>();
    for (const session of expiredSessions) {
      if (!userSessions.has(session.userId)) {
        userSessions.set(session.userId, []);
      }
      userSessions.get(session.userId)!.push(session.id);

      // 清除 Redis 中的会话缓存
      await redis.del(`session:${session.token}`);
    }

    // 删除数据库中的过期会话
    await db
      .delete(sessions)
      .where(lt(sessions.expiresAt, now));

    // 获取每个用户的活跃会话
    for (const [userId, _] of userSessions) {
      const activeSessions = await db
        .select({ id: sessions.id })
        .from(sessions)
        .where(and(
          eq(sessions.userId, userId),
          lt(sessions.expiresAt, now)
        ));

      const activeSessionIds = activeSessions.map(s => s.id);

      // 清理设备中的过期会话
      await cleanupUserSessions(userId, activeSessionIds);
    }

    logger.info({
      taskName: 'cleanupExpiredSessions',
      deletedCount: expiredSessions.length,
      message: `清理了 ${expiredSessions.length} 个过期会话`,
    });
  } catch (error) {
    logger.error({
      taskName: 'cleanupExpiredSessions',
      error,
      message: '清理过期会话时发生错误',
    });
    throw error;
  }
}
```

---

## 4. 前端集成

### 4.1 设备列表组件

**文件**：`mianshihou/apps/web/src/components/DeviceList.tsx`

```typescript
'use client';

import { useQuery, useMutation } from '@tanstack/react-query';
import { api } from '@/lib/trpc';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

export function DeviceList() {
  const { data: devices, isLoading } = useQuery({
    queryKey: ['devices'],
    queryFn: () => api.auth.myDevices.query(),
  });

  const revokeDevice = useMutation({
    mutationFn: (deviceFingerprint: string) =>
      api.auth.revokeDevice.mutate({ deviceFingerprint }),
    onSuccess: () => {
      toast.success('设备已移除');
    },
  });

  const revokeAllDevices = useMutation({
    mutationFn: () => api.auth.revokeAllDevices.mutate(),
    onSuccess: () => {
      toast.success('已踢出所有其他设备');
    },
  });

  if (isLoading) return <div>加载中...</div>;

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-xl font-semibold">活跃设备</h2>
        <button
          onClick={() => revokeAllDevices.mutate()}
          className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          踢出所有设备
        </button>
      </div>

      <div className="space-y-3">
        {devices?.map((device) => (
          <div
            key={device.fingerprint}
            className="p-4 border rounded-lg flex justify-between items-center"
          >
            <div>
              <div className="font-medium">{device.deviceName}</div>
              <div className="text-sm text-gray-500">
                {device.platform} · {device.browser}
              </div>
              <div className="text-xs text-gray-400">
                上次活跃: {formatDistanceToNow(new Date(device.lastSeen), {
                  addSuffix: true,
                  locale: zhCN,
                })}
              </div>
            </div>
            <button
              onClick={() => revokeDevice.mutate(device.fingerprint)}
              className="px-3 py-1 text-sm text-red-500 hover:text-red-700"
            >
              移除
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 5. 单元测试

### 5.1 设备指纹测试

**文件**：`mianshihou/apps/api/tests/unit/device-fingerprint.test.ts`

```typescript
import { describe, expect, test } from 'bun:test';
import { generateDeviceFingerprint, generateDeviceInfo, parseDeviceInfo } from '@/lib/device-fingerprint';

describe('Device Fingerprint', () => {
  test('相同IP和UA应该生成相同指纹', () => {
    const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)';
    const ip = '192.168.1.1';
    const fp1 = generateDeviceFingerprint(ip, ua);
    const fp2 = generateDeviceFingerprint(ip, ua);

    expect(fp1).toBe(fp2);
  });

  test('不同IP应该生成不同指纹', () => {
    const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)';
    const fp1 = generateDeviceFingerprint('192.168.1.1', ua);
    const fp2 = generateDeviceFingerprint('192.168.1.2', ua);

    expect(fp1).not.toBe(fp2);
  });

  test('应该正确解析设备信息', () => {
    const tests = [
      {
        ua: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0)',
        expected: { deviceName: 'iOS Device', platform: 'iOS', browser: 'Safari' },
      },
      {
        ua: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0',
        expected: { deviceName: 'Windows PC', platform: 'Windows', browser: 'Chrome' },
      },
    ];

    for (const { ua, expected } of tests) {
      const info = parseDeviceInfo(ua);
      expect(info.deviceName).toBe(expected.deviceName);
      expect(info.platform).toBe(expected.platform);
      expect(info.browser).toBe(expected.browser);
    }
  });
});
```

### 5.2 并发登录测试

**文件**：`mianshihou/apps/api/tests/unit/concurrent-login.test.ts`

```typescript
import { describe, expect, test, beforeAll, afterAll } from 'bun:test';
import { redis } from '@/lib/redis';
import { handleConcurrentLogin, getUserActiveDevices, revokeDevice } from '@/lib/concurrent-login';

const TEST_USER_ID = 'test-user-123';

describe('Concurrent Login', () => {
  beforeAll(async () => {
    // 清理测试数据
    await redis.del(`devices:${TEST_USER_ID}`);
  });

  afterAll(async () => {
    // 清理测试数据
    const devices = await redis.lrange(`devices:${TEST_USER_ID}`, 0, -1);
    for (const fp of devices) {
      await redis.del(`device:${TEST_USER_ID}:${fp}`);
      await redis.del(`device_sessions:${TEST_USER_ID}:${fp}`);
    }
    await redis.del(`devices:${TEST_USER_ID}`);
  });

  test('应该允许第一个设备登录', async () => {
    const result = await handleConcurrentLogin(
      TEST_USER_ID,
      '192.168.1.1',
      'Mozilla/5.0 Chrome',
      'session-1',
      { maxDevices: 3, onNewLogin: 'kick_oldest' }
    );

    expect(result.allowed).toBe(true);
  });

  test('应该允许在限制内的多个设备登录', async () => {
    // 添加3个设备
    for (let i = 1; i <= 3; i++) {
      await handleConcurrentLogin(
        TEST_USER_ID,
        `192.168.1.${i}`,
        `Mozilla/5.0 Device${i}`,
        `session-${i}`,
        { maxDevices: 3, onNewLogin: 'deny' }
      );
    }

    // 第4个设备应该被拒绝
    const result = await handleConcurrentLogin(
      TEST_USER_ID,
      '192.168.1.4',
      'Mozilla/5.0 Device4',
      'session-4',
      { maxDevices: 3, onNewLogin: 'deny' }
    );

    expect(result.allowed).toBe(false);
    expect(result.message).toContain('达到上限');
  });

  test('应该允许已知设备重复登录', async () => {
    const result = await handleConcurrentLogin(
      TEST_USER_ID,
      '192.168.1.1',
      'Mozilla/5.0 Chrome',
      'session-5',
      { maxDevices: 3, onNewLogin: 'deny' }
    );

    expect(result.allowed).toBe(true);
  });

  test('应该正确获取用户活跃设备列表', async () => {
    const devices = await getUserActiveDevices(TEST_USER_ID);

    expect(devices.length).toBe(3);
    expect(devices.every(d => d.fingerprint)).toBe(true);
  });

  test('应该能够踢出指定设备', async () => {
    const devicesBefore = await getUserActiveDevices(TEST_USER_ID);
    const deviceToRemove = devicesBefore[0];

    await revokeDevice(TEST_USER_ID, deviceToRemove.fingerprint);

    const devicesAfter = await getUserActiveDevices(TEST_USER_ID);
    expect(devicesAfter.length).toBe(devicesBefore.length - 1);
    expect(devicesAfter.find(d => d.fingerprint === deviceToRemove.fingerprint)).toBeUndefined();
  });
});
```

---

## 6. 部署计划

### 6.1 无需数据库迁移
本方案**不需要任何数据库迁移**，完全基于 Redis 实现。

### 6.2 确认 Redis 运行
```bash
# 检查 Redis 状态
redis-cli ping
```

### 6.3 部署步骤
1. 创建新的模块文件
2. 更新认证路由
3. 运行单元测试
4. 部署到生产环境

---

## 7. 优势与限制

### 7.1 优势
- ✅ **零数据库迁移**：不修改 Better-Auth 表结构
- ✅ **实现简单**：纯 Redis 方案，代码量少
- ✅ **降级友好**：Redis 故障时不影响正常登录
- ✅ **向后兼容**：不影响现有功能

### 7.2 限制
- ⚠️ **完全依赖 Redis**：如果 Redis 故障，设备信息会丢失
- ⚠️ **设备指纹准确度**：仅基于 IP 和 UA，可能误判
- ⚠️ **IP 变化**：用户更换 IP 后会被识别为新设备

### 7.3 缓解措施
- Redis 故障时自动降级，允许登录
- 提供设备管理界面，用户可手动踢出设备
- 记录设备首次登录信息，便于识别

---

## 8. 总结

本方案提供了一个**无需修改数据库表**的设备识别和并发登录检测解决方案：

1. **设备指纹**：基于 IP 和 User-Agent 生成
2. **Redis 存储**：所有设备信息和会话管理
3. **并发控制**：限制同时登录的设备数量
4. **设备管理**：提供设备列表和踢出功能

该方案简单、高效，适合快速实现，同时保持了系统的稳定性和可维护性。