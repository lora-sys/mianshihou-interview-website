# 设备识别和并发登录检测计划

## 1. 概述

本计划旨在实现设备识别和并发登录检测功能，提升系统安全性和用户体验。

### 1.1 目标
- **设备识别**：唯一标识每个登录设备，区分不同设备上的会话
- **并发登录检测**：监控和控制同一账号的并发登录行为
- **安全增强**：防止账号被盗用，提供异常登录告警

### 1.2 范围
- 设备指纹生成和管理
- 并发登录策略和限制
- 会话管理和清理
- 用户通知和日志记录

---

## 2. 现有架构分析

### 2.1 当前认证系统
- **认证框架**：Better-Auth
- **会话存储**：PostgreSQL `session` 表
- **现有会话字段**：
  - `id`: 会话ID
  - `userId`: 用户ID
  - `token`: 访问令牌
  - `expiresAt`: 过期时间
  - `ipAddress`: IP地址
  - `userAgent`: 用户代理
  - `createdAt`: 创建时间
  - `updatedAt`: 更新时间

### 2.2 现有问题
1. 缺少设备唯一标识
2. 无法区分同一设备的不同会话
3. 无并发登录限制机制
4. 无异常登录检测和告警

---

## 3. 技术方案

### 3.1 设备识别方案

#### 方案A：基于客户端指纹（推荐）
- 使用 `fingerprintjs` 生成设备指纹
- 结合浏览器特征生成唯一ID
- 优点：准确度高、跨浏览器一致性较好
- 缺点：需要前端集成

#### 方案B：基于IP和User-Agent
- 使用IP地址和User-Agent哈希
- 优点：简单、无需额外依赖
- 缺点：准确度较低、容易误判

**采用方案A（客户端指纹）+ 方案B（IP和UA）组合策略**

### 3.2 并发登录策略

#### 策略选项
1. **严格模式**：只允许一个设备登录，新登录踢出旧登录
2. **限制模式**：允许最多N个设备同时登录
3. **通知模式**：允许所有登录，但向用户通知新设备登录

**默认采用策略2（限制模式，最多3个设备）**

### 3.3 数据存储方案

#### PostgreSQL 表结构变更
```sql
-- 修改 session 表，添加设备指纹字段
ALTER TABLE session ADD COLUMN device_fingerprint VARCHAR(256);
ALTER TABLE session ADD COLUMN device_name VARCHAR(256);
ALTER TABLE session ADD COLUMN is_active BOOLEAN DEFAULT true;
ALTER TABLE session ADD COLUMN last_active_at TIMESTAMP;

-- 创建索引优化查询
CREATE INDEX idx_session_user_device ON session(user_id, device_fingerprint);
CREATE INDEX idx_session_active ON session(user_id, is_active, last_active_at);
```

#### Redis 缓存策略
```
Key: device:{userId}:{deviceFingerprint}
Value: {
  sessionId: string,
  lastActive: timestamp,
  deviceName: string
}
TTL: 会话过期时间

Key: active_devices:{userId}
Value: [deviceFingerprint1, deviceFingerprint2, ...]
TTL: 会话过期时间
```

---

## 4. 实现步骤

### 4.1 数据库迁移

#### 文件：`mianshihou/apps/api/drizzle/0001_add_device_fingerprint.sql`
```sql
-- 添加设备指纹相关字段
ALTER TABLE session ADD COLUMN IF NOT EXISTS device_fingerprint VARCHAR(256);
ALTER TABLE session IF NOT EXISTS ADD COLUMN device_name VARCHAR(256);
ALTER TABLE session IF NOT EXISTS ADD COLUMN is_active BOOLEAN DEFAULT true;
ALTER TABLE session IF NOT EXISTS ADD COLUMN last_active_at TIMESTAMP DEFAULT NOW();

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_session_user_device ON session(user_id, device_fingerprint);
CREATE INDEX IF NOT EXISTS idx_session_active ON session(user_id, is_active, last_active_at);
```

#### 更新 Drizzle Schema
```typescript
// mianshihou/apps/api/db/schema.ts
export const sessions = pgTable(
  'session',
  {
    id: text('id').primaryKey(),
    userId: text('user_id')
      .notNull()
      .references(() => users.id, { onDelete: 'cascade' }),
    expiresAt: timestamp('expires_at').notNull(),
    token: text('token').notNull().unique(),
    ipAddress: text('ip_address'),
    userAgent: text('user_agent'),
    deviceFingerprint: varchar('device_fingerprint', { length: 256 }),
    deviceName: varchar('device_name', { length: 256 }),
    isActive: boolean('is_active').default(true).notNull(),
    lastActiveAt: timestamp('last_active_at'),
    createdAt: timestamp('created_at').defaultNow().notNull(),
    updatedAt: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => [
    index('session_userId_idx').on(table.userId),
    index('idx_session_user_device').on(table.userId, table.deviceFingerprint),
    index('idx_session_active').on(table.userId, table.isActive, table.lastActiveAt),
  ]
);
```

### 4.2 核心模块开发

#### 4.2.1 设备指纹模块
**文件**：`mianshihou/apps/api/lib/device-fingerprint.ts`

```typescript
import crypto from 'crypto';

/**
 * 设备指纹接口
 */
export interface DeviceInfo {
  fingerprint: string;
  deviceName: string;
  platform: string;
  browser: string;
}

/**
 * 从客户端请求生成设备信息
 */
export function generateDeviceInfo(
  userAgent: string,
  ipAddress: string,
  clientFingerprint?: string
): DeviceInfo {
  // 如果客户端提供了指纹，直接使用
  if (clientFingerprint) {
    return {
      fingerprint: clientFingerprint,
      deviceName: extractDeviceName(userAgent),
      platform: extractPlatform(userAgent),
      browser: extractBrowser(userAgent),
    };
  }

  // 否则基于IP和User-Agent生成指纹
  const rawFingerprint = `${userAgent}:${ipAddress}`;
  const fingerprint = crypto
    .createHash('sha256')
    .update(rawFingerprint)
    .digest('hex')
    .substring(0, 32);

  return {
    fingerprint,
    deviceName: extractDeviceName(userAgent),
    platform: extractPlatform(userAgent),
    browser: extractBrowser(userAgent),
  };
}

/**
 * 提取设备名称
 */
function extractDeviceName(userAgent: string): string {
  const ua = userAgent.toLowerCase();

  if (ua.includes('mobile')) return 'Mobile Device';
  if (ua.includes('tablet')) return 'Tablet';
  if (ua.includes('android')) return 'Android Device';
  if (ua.includes('iphone') || ua.includes('ipad')) return 'iOS Device';
  if (ua.includes('mac')) return 'Macintosh';
  if (ua.includes('windows')) return 'Windows PC';
  if (ua.includes('linux')) return 'Linux PC';

  return 'Unknown Device';
}

/**
 * 提取平台
 */
function extractPlatform(userAgent: string): string {
  const ua = userAgent.toLowerCase();

  if (ua.includes('android')) return 'Android';
  if (ua.includes('iphone') || ua.includes('ipad')) return 'iOS';
  if (ua.includes('mac os')) return 'macOS';
  if (ua.includes('windows')) return 'Windows';
  if (ua.includes('linux')) return 'Linux';

  return 'Unknown';
}

/**
 * 提取浏览器
 */
function extractBrowser(userAgent: string): string {
  const ua = userAgent.toLowerCase();

  if (ua.includes('edg/')) return 'Edge';
  if (ua.includes('chrome/') && !ua.includes('edg/')) return 'Chrome';
  if (ua.includes('firefox/')) return 'Firefox';
  if (ua.includes('safari/') && !ua.includes('chrome/')) return 'Safari';

  return 'Unknown';
}
```

#### 4.2.2 并发登录检测模块
**文件**：`mianshihou/apps/api/lib/concurrent-login.ts`

```typescript
import { db } from '@/db';
import { sessions } from '@/db/schema';
import { eq, and, desc } from 'drizzle-orm';
import { redis } from '@/lib/redis';
import { logger } from '@/lib/logger';
import { AppError } from '@/lib/errors';

export interface ConcurrentLoginConfig {
  maxDevices: number;
  allowMultipleSessions: boolean;
  onNewLogin: 'kick_oldest' | 'deny' | 'allow';
}

const DEFAULT_CONFIG: ConcurrentLoginConfig = {
  maxDevices: 3,
  allowMultipleSessions: true,
  onNewLogin: 'kick_oldest',
};

/**
 * 检查并发登录状态
 */
export async function checkConcurrentLogin(
  userId: string,
  deviceFingerprint: string,
  config: ConcurrentLoginConfig = DEFAULT_CONFIG
): Promise<{ allowed: boolean; message?: string }> {
  try {
    // 获取用户所有活跃会话
    const activeSessions = await db
      .select()
      .from(sessions)
      .where(and(
        eq(sessions.userId, userId),
        eq(sessions.isActive, true)
      ))
      .orderBy(desc(sessions.lastActiveAt));

    // 按设备分组
    const deviceSessions = new Map<string, typeof activeSessions>();
    for (const session of activeSessions) {
      const fp = session.deviceFingerprint || 'unknown';
      if (!deviceSessions.has(fp)) {
        deviceSessions.set(fp, []);
      }
      deviceSessions.get(fp)!.push(session);
    }

    const uniqueDevices = deviceSessions.size;

    // 检查是否已达到设备上限
    if (uniqueDevices >= config.maxDevices) {
      // 检查是否是已知的设备
      if (deviceSessions.has(deviceFingerprint)) {
        return { allowed: true };
      }

      // 新设备登录
      switch (config.onNewLogin) {
        case 'deny':
          return {
            allowed: false,
            message: `登录失败：您已在${uniqueDevices}个设备上登录，达到上限`,
          };
        case 'kick_oldest':
          await removeOldestSession(userId);
          logger.info({
            context: 'ConcurrentLogin',
            userId,
            message: '踢出最旧的会话以允许新设备登录',
          });
          return { allowed: true };
        case 'allow':
          return { allowed: true };
      }
    }

    return { allowed: true };
  } catch (error) {
    logger.error({
      context: 'ConcurrentLogin',
      userId,
      error,
      message: '检查并发登录时发生错误',
    });
    // 出错时允许登录，避免阻塞用户
    return { allowed: true };
  }
}

/**
 * 移除最旧的活跃会话
 */
async function removeOldestSession(userId: string): Promise<void> {
  const oldestSession = await db
    .select()
    .from(sessions)
    .where(and(
      eq(sessions.userId, userId),
      eq(sessions.isActive, true)
    ))
    .orderBy(sessions.lastActiveAt)
    .limit(1);

  if (oldestSession.length > 0) {
    await db
      .update(sessions)
      .set({ isActive: false })
      .where(eq(sessions.id, oldestSession[0].id));

    // 清除Redis缓存
    await redis.del(`session:${oldestSession[0].token}`);

    logger.info({
      context: 'ConcurrentLogin',
      userId,
      sessionId: oldestSession[0].id,
      message: '移除最旧的会话',
    });
  }
}

/**
 * 更新会话最后活跃时间
 */
export async function updateSessionActivity(
  sessionId: string,
  userId: string
): Promise<void> {
  await db
    .update(sessions)
    .set({ lastActiveAt: new Date() })
    .where(and(
      eq(sessions.id, sessionId),
      eq(sessions.userId, userId)
    ));
}

/**
 * 获取用户的所有活跃设备
 */
export async function getUserActiveDevices(userId: string) {
  const activeSessions = await db
    .select({
      deviceFingerprint: sessions.deviceFingerprint,
      deviceName: sessions.deviceName,
      lastActiveAt: sessions.lastActiveAt,
      ipAddress: sessions.ipAddress,
    })
    .from(sessions)
    .where(and(
      eq(sessions.userId, userId),
      eq(sessions.isActive, true)
    ))
    .orderBy(desc(sessions.lastActiveAt));

  // 去重设备
  const devices = new Map();
  for (const session of activeSessions) {
    const fp = session.deviceFingerprint || 'unknown';
    if (!devices.has(fp)) {
      devices.set(fp, {
        fingerprint: fp,
        name: session.deviceName || 'Unknown Device',
        lastActive: session.lastActiveAt,
        ipAddress: session.ipAddress,
      });
    }
  }

  return Array.from(devices.values());
}
```

#### 4.2.3 更新认证流程

**文件**：`mianshihou/apps/api/trpc/router/auth.ts`

```typescript
import { z } from 'zod';
import { publicProcedure, router } from '../index';
import { auth } from '@/lib/auth';
import { generateDeviceInfo } from '@/lib/device-fingerprint';
import { checkConcurrentLogin, updateSessionActivity } from '@/lib/concurrent-login';
import { db } from '@/db';
import { sessions } from '@/db/schema';

export const authRouter = router({
  // ... 其他路由

  signIn: publicProcedure
    .input(z.object({
      email: z.string().email(),
      password: z.string(),
      deviceFingerprint: z.string().optional(), // 客户端可选提供
    }))
    .mutation(async ({ input, ctx }) => {
      // Better-Auth 登录
      const session = await auth.api.signInEmail({
        body: {
          email: input.email,
          password: input.password,
        },
      });

      if (!session) {
        throw new AppError('INVALID_CREDENTIALS', '邮箱或密码错误');
      }

      // 生成设备信息
      const deviceInfo = generateDeviceInfo(
        ctx.request.headers['user-agent'] || '',
        ctx.ip || '',
        input.deviceFingerprint
      );

      // 检查并发登录
      const concurrentCheck = await checkConcurrentLogin(
        session.user.id,
        deviceInfo.fingerprint
      );

      if (!concurrentCheck.allowed) {
        throw new AppError(
          'CONCURRENT_LOGIN_LIMIT',
          concurrentCheck.message || '达到设备登录上限'
        );
      }

      // 更新会话的设备信息
      await db
        .update(sessions)
        .set({
          deviceFingerprint: deviceInfo.fingerprint,
          deviceName: deviceInfo.deviceName,
          lastActiveAt: new Date(),
        })
        .where(eq(sessions.id, session.session.id));

      logger.info({
        context: 'Auth',
        userId: session.user.id,
        deviceFingerprint: deviceInfo.fingerprint,
        message: '用户登录成功',
      });

      return session;
    }),

  // 获取当前用户的活跃设备列表
  myDevices: publicProcedure
    .mutation(async ({ ctx }) => {
      const session = await auth.api.getSession({ headers: ctx.request.headers });
      if (!session) {
        throw new AppError('UNAUTHORIZED', '未登录');
      }

      const devices = await getUserActiveDevices(session.user.id);
      return devices;
    }),

  // 踢出指定设备的所有会话
  revokeDevice: publicProcedure
    .input(z.object({
      deviceFingerprint: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      const session = await auth.api.getSession({ headers: ctx.request.headers });
      if (!session) {
        throw new AppError('UNAUTHORIZED', '未登录');
      }

      await db
        .update(sessions)
        .set({ isActive: false })
        .where(and(
          eq(sessions.userId, session.user.id),
          eq(sessions.deviceFingerprint, input.deviceFingerprint),
          eq(sessions.isActive, true)
        ));

      logger.info({
        context: 'Auth',
        userId: session.user.id,
        deviceFingerprint: input.deviceFingerprint,
        message: '用户踢出设备',
      });

      return { success: true };
    }),
});
```

### 4.3 前端集成

#### 4.3.1 安装 FingerprintJS
```bash
cd mianshihou/apps/web
bun add @fingerprintjs/fingerprintjs
```

#### 4.3.2 创建设备指纹钩子
**文件**：`mianshihou/apps/web/src/hooks/useDeviceFingerprint.ts`

```typescript
import { useState, useEffect } from 'react';
import FingerprintJS from '@fingerprintjs/fingerprintjs';

export function useDeviceFingerprint() {
  const [fingerprint, setFingerprint] = useState<string>('');
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function init() {
      try {
        const fp = await FingerprintJS.load();
        const result = await fp.get();
        setFingerprint(result.visitorId);
      } catch (error) {
        console.error('Failed to load fingerprint:', error);
      } finally {
        setLoading(false);
      }
    }

    init();
  }, []);

  return { fingerprint, loading };
}
```

#### 4.3.3 更新登录组件
**文件**：`mianshihou/apps/web/src/components/SignInForm.tsx`

```typescript
import { useDeviceFingerprint } from '@/hooks/useDeviceFingerprint';
// ... 其他导入

export function SignInForm() {
  const { fingerprint, loading: fpLoading } = useDeviceFingerprint();
  const signIn = useMutation(api.auth.signIn);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (fpLoading) {
      toast.error('正在初始化设备识别...');
      return;
    }

    signIn.mutate(
      {
        email,
        password,
        deviceFingerprint: fingerprint || undefined,
      },
      {
        onSuccess: () => {
          toast.success('登录成功');
          router.push('/');
        },
        onError: (error) => {
          toast.error(error.message);
        },
      }
    );
  };

  // ... 组件其余部分
}
```

### 4.4 单元测试

#### 4.4.1 设备指纹测试
**文件**：`mianshihou/apps/api/tests/unit/device-fingerprint.test.ts`

```typescript
import { describe, expect, test } from 'bun:test';
import { generateDeviceInfo } from '@/lib/device-fingerprint';

describe('Device Fingerprint', () => {
  test('应该生成唯一的设备指纹', () => {
    const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)';
    const device1 = generateDeviceInfo(ua, '192.168.1.1');
    const device2 = generateDeviceInfo(ua, '192.168.1.2');

    expect(device1.fingerprint).not.toBe(device2.fingerprint);
  });

  test('相同IP和UA应该生成相同指纹', () => {
    const ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)';
    const ip = '192.168.1.1';
    const device1 = generateDeviceInfo(ua, ip);
    const device2 = generateDeviceInfo(ua, ip);

    expect(device1.fingerprint).toBe(device2.fingerprint);
  });

  test('应该正确提取设备名称', () => {
    const tests = [
      { ua: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0)', expected: 'iOS Device' },
      { ua: 'Mozilla/5.0 (Linux; Android 10)', expected: 'Android Device' },
      { ua: 'Mozilla/5.0 (Macintosh; Intel Mac OS X)', expected: 'Macintosh' },
      { ua: 'Mozilla/5.0 (Windows NT 10.0)', expected: 'Windows PC' },
    ];

    for (const { ua, expected } of tests) {
      const device = generateDeviceInfo(ua, '192.168.1.1');
      expect(device.deviceName).toBe(expected);
    }
  });
});
```

#### 4.4.2 并发登录测试
**文件**：`mianshihou/apps/api/tests/unit/concurrent-login.test.ts`

```typescript
import { describe, expect, test, beforeAll, afterAll } from 'bun:test';
import { checkConcurrentLogin, getUserActiveDevices } from '@/lib/concurrent-login';
import { db } from '@/db';
import { sessions, users } from '@/db/schema';

describe('Concurrent Login', () => {
  let testUserId: string;

  beforeAll(async () => {
    // 创建测试用户
    const [user] = await db.insert(users).values({
      id: `test-user-${Date.now()}`,
      email: 'test@example.com',
      userAccount: 'testuser',
    }).returning();
    testUserId = user.id;
  });

  afterAll(async () => {
    // 清理测试数据
    await db.delete(sessions).where(eq(sessions.userId, testUserId));
    await db.delete(users).where(eq(users.id, testUserId));
  });

  test('应该允许第一个设备登录', async () => {
    const result = await checkConcurrentLogin(testUserId, 'device-1', {
      maxDevices: 3,
      allowMultipleSessions: true,
      onNewLogin: 'kick_oldest',
    });

    expect(result.allowed).toBe(true);
  });

  test('应该允许在限制内的多个设备登录', async () => {
    // 创建3个会话
    for (let i = 1; i <= 3; i++) {
      await db.insert(sessions).values({
        id: `session-${i}`,
        userId: testUserId,
        token: `token-${i}`,
        expiresAt: new Date(Date.now() + 3600000),
        deviceFingerprint: `device-${i}`,
        isActive: true,
        lastActiveAt: new Date(),
      });
    }

    const result = await checkConcurrentLogin(testUserId, 'device-4', {
      maxDevices: 3,
      allowMultipleSessions: true,
      onNewLogin: 'deny',
    });

    expect(result.allowed).toBe(false);
    expect(result.message).toContain('达到上限');
  });

  test('应该允许已知设备重复登录', async () => {
    const result = await checkConcurrentLogin(testUserId, 'device-1', {
      maxDevices: 3,
      allowMultipleSessions: true,
      onNewLogin: 'deny',
    });

    expect(result.allowed).toBe(true);
  });

  test('应该正确获取用户活跃设备列表', async () => {
    const devices = await getUserActiveDevices(testUserId);

    expect(devices.length).toBe(3);
    expect(devices.every(d => d.fingerprint)).toBe(true);
  });
});
```

---

## 5. 部署计划

### 5.1 数据库迁移
```bash
cd mianshihou/apps/api
bun run drizzle-kit generate
bun run drizzle-kit migrate
```

### 5.2 环境变量
无需新增环境变量

### 5.3 依赖安装
```bash
# 后端
cd mianshihou/apps/api
bun add @fingerprintjs/fingerprintjs

# 前端
cd mianshihou/apps/web
bun add @fingerprintjs/fingerprintjs
```

### 5.4 Redis 确认
确保 Redis 服务正常运行，用于会话缓存

---

## 6. 安全考虑

### 6.1 设备指纹安全
- 客户端指纹可能被伪造，仅作为辅助手段
- 结合 IP 地址进行二次验证
- 异常 IP 变更时要求重新认证

### 6.2 会话安全
- 敏感操作（如修改密码）需要二次验证
- 长时间未活跃的会话自动失效
- 定期清理过期会话

### 6.3 隐私保护
- 设备信息加密存储
- 用户可查看和管理登录设备
- 提供"一键退出所有设备"功能

---

## 7. 监控和日志

### 7.1 日志记录
- 新设备登录：记录设备信息、IP地址
- 会话被踢出：记录原因和时间
- 异常登录检测：识别可疑登录行为

### 7.2 监控指标
- 活跃设备数
- 会话创建/销毁频率
- 并发登录拒绝次数
- 设备指纹碰撞率

---

## 8. 后续优化

### 8.1 短期优化
- 添加设备信任机制（记住设备）
- 实现异地登录告警
- 提供设备登录历史记录

### 8.2 长期优化
- 引入设备风险评分
- 支持生物识别登录
- 实现自适应安全策略

---

## 9. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 设备指纹被伪造 | 高 | 中 | 结合IP、地理位置等多因素验证 |
| 正常用户被误踢出 | 中 | 低 | 提供设备管理界面，允许用户恢复 |
| 数据库性能下降 | 中 | 低 | 添加索引，使用Redis缓存 |
| FingerprintJS 加载失败 | 低 | 低 | 降级到基于IP+UA的指纹 |

---

## 10. 测试清单

- [ ] 单元测试：设备指纹生成
- [ ] 单元测试：并发登录检测
- [ ] 集成测试：完整登录流程
- [ ] 集成测试：设备上限限制
- [ ] 集成测试：会话踢出
- [ ] 前端测试：FingerprintJS集成
- [ ] 前端测试：设备列表展示
- [ ] 性能测试：大量并发登录场景
- [ ] 安全测试：设备指纹伪造防护

---

## 11. 实施时间表

| 阶段 | 任务 | 预计工作量 |
|------|------|------------|
| Phase 1 | 数据库迁移和Schema更新 | 0.5天 |
| Phase 2 | 后端核心模块开发 | 2天 |
| Phase 3 | 单元测试 | 1天 |
| Phase 4 | 前端集成 | 1天 |
| Phase 5 | 集成测试和调试 | 1天 |
| Phase 6 | 部署和监控 | 0.5天 |

**总计：约6个工作日**

---

## 12. 总结

本计划实现了一个完整的设备识别和并发登录检测系统，通过以下方式提升安全性：

1. **设备指纹**：使用 FingerprintJS 生成唯一设备标识
2. **并发控制**：限制同时登录的设备数量
3. **会话管理**：提供设备管理和会话踢出功能
4. **安全增强**：异常登录检测和告警

系统采用渐进式增强策略，确保在各种网络环境下都能正常工作。